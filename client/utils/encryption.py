"""
Thin wrapper around pyaes that fixes a mode and encryption style, along with a standard format
for encrypted text to be stored in that allows for easily determining the difference between an encrypted and
non-encrypted file.
"""
import base64
import os

import pyaes

HEADER_TEXT = "OKPY ENCRYPTED FILE FOLLOWS\n" + "-" * 100 + "\n"

# used to ensure that the key us correct (helps detect incorrect key usage)
PLAINTEXT_PADDING = b"0" * 16


def generate_key() -> str:
    """
    Generates a random key
    """
    return to_safe_string(os.urandom(32))


def encrypt(data: str, key: str) -> str:
    """
    Encrypt the given data using the given key. Tag the result so that it is clear that this is an encrypted file.
    """
    data_as_bytes = PLAINTEXT_PADDING + data.encode('utf-8')

    ciphertext = aes_mode_of_operation(key).encrypt(data_as_bytes)
    encoded_ciphertext = HEADER_TEXT + to_safe_string(ciphertext)
    return encoded_ciphertext


def is_encrypted(encoded_ciphertext: str) -> bool:
    return encoded_ciphertext.startswith(HEADER_TEXT)


def decrypt(encoded_ciphertext: str, key: str) -> str:
    """
    Decrypt the given ciphertext with the given key. The ciphertext must correspond to the format as generated by
        encrypt(data, key)
    """
    if not encoded_ciphertext.startswith(HEADER_TEXT):
        raise ValueError("Invalid ciphertext: does not start with the header")

    ciphertext_no_header = encoded_ciphertext[len(HEADER_TEXT):]
    ciphertext_no_header_bytes = from_safe_string(ciphertext_no_header)
    padded_plaintext = aes_mode_of_operation(key).decrypt(ciphertext_no_header_bytes)
    if not padded_plaintext.startswith(PLAINTEXT_PADDING):
        raise InvalidKeyException
    plaintext = padded_plaintext[len(PLAINTEXT_PADDING):]
    return plaintext.decode('utf-8')


def to_safe_string(unsafe_bytes: bytes) -> str:
    # use 9 instead of = for padding so that the string looks more homogenous
    return base64.b32encode(unsafe_bytes).decode('ascii').replace("=", "9").lower()


def from_safe_string(safe_string: str) -> bytes:
    return base64.b32decode(safe_string.upper().replace("9", "=").encode('ascii'))


def aes_mode_of_operation(key):
    return pyaes.AESModeOfOperationCTR(from_safe_string(key))


class InvalidKeyException(Exception):
    pass
