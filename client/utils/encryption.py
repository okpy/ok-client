"""
Thin wrapper around the pypi `encryption` library that fixes the block mode and cipher, along with a standard format
for encrypted text to be stored in that allows for easily determining the difference between an encrypted and
non-encrypted file.
"""
import base64

from cryptography.fernet import Fernet, InvalidToken

HEADER_TEXT = "OKPY ENCRYPTED FILE FOLLOWS\n" + "-" * 100 + "\n"


def generate_key() -> bytes:
    """
    Generates a random key
    """
    return Fernet.generate_key()


def encrypt(data: str, key: bytes) -> str:
    """
    Encrypt the given data using the given key. Tag the result so that it is clear that this is an encrypted file.
    """
    data_as_bytes = data.encode('utf-8')

    encoded_ciphertext = HEADER_TEXT + base64.b64encode(Fernet(key).encrypt(data_as_bytes)).decode('ascii')
    return encoded_ciphertext


def is_encrypted(encoded_ciphertext: str) -> bool:
    return encoded_ciphertext.startswith(HEADER_TEXT)


def decrypt(encoded_ciphertext: str, key: bytes) -> str:
    """
    Decrypt the given ciphertext with the given key. The ciphertext must correspond to the format as generated by
        encrypt(data, key)
    """
    if not encoded_ciphertext.startswith(HEADER_TEXT):
        raise ValueError("Invalid ciphertext: does not start with the header")
    encoded_ciphertext = encoded_ciphertext[len(HEADER_TEXT):]
    encoded_ciphertext = base64.b64decode(encoded_ciphertext.encode('ascii'))
    try:
        return Fernet(key).decrypt(encoded_ciphertext).decode('utf-8')
    except InvalidToken:
        raise InvalidKeyException("Invalid key: {}".format(key))


class InvalidKeyException(Exception):
    pass
